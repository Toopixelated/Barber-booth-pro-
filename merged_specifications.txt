# MERGED & DE-DUPLICATED SPECIFICATIONS

This file is a combination of all the specification-related documents in the repository, with redundant information removed to reduce the context size for AI tools.

The original files were:
- AI prompt.txt
- designspec.txt
- readme.txt
- README.md
- workspace_context.txt

---
---
# 1. Overview & Core Mission (from designspec.txt)
---

Barber Booth Pro is a client-only Progressive Web App (PWA) designed to provide users with a photorealistic, multi-angle preview of a new hairstyle using generative AI. The application prioritizes a seamless, mobile-first user experience, high-quality visual output, and robust error handling within the constraints of a browser-based environment.

## 1.1. Core Principles (Constitution)
- **PWA-First**: The application must be installable, function offline where possible (core shell), and feel native.
- **Simplicity**: Maintain a single, client-side codebase. Prefer stable, built-in solutions over complex, external dependencies (e.g., default upscaler model as a fallback).
- **Test-First Mindset**: Features are designed with testability in mind, covering primary user stories, edge cases (e.g., network failure, hardware limitations), and performance.
- **Observability**: Provide clear, real-time feedback to the user for all asynchronous operations (e.g., progress toasts, loading states, descriptive errors).

---
---
# 2. Technology Stack (from designspec.txt)
---

- **Language**: TypeScript / React 19
- **State Management**: Zustand v4.5.5
- **AI Services**:
    - **Google Gemini API**: `@google/genai` v1.14.0
    - **Image Generation Model**: `gemini-2.5-flash-image-preview`
    - **Video Generation Model**: `veo-2.0-generate-001`
    - **Text Suggestion Model**: `gemini-2.5-flash`
- **Image Upscaling**:
    - **Library**: `upscaler` v1.0.0-beta.19
    - **Backend**: `@tensorflow/tfjs` v4.20.0 (WebGL with CPU fallback)
    - **Dynamic Model**: `@upscalerjs/esrgan-slim` v1.0.0-beta.12 (4x scale)
- **Styling & UI**: Tailwind CSS, Framer Motion, Radix UI, React Colorful, `react-image-crop`
- **Environment**: Sandboxed IDE with `importmap`, Client-only.

---
---
# 3. Feature Specifications (from designspec.txt)
---

### 3.1. Feature: PWA & Core App Shell
- **Execution Flow**:
    1. `index.html` loads the application and registers the service worker via a script tag pointing to `./service-worker.js`.
    2. The `service-worker.js` script caches core assets (`/`, `./index.html`, `./index.css`, `./index.tsx`) upon installation.
    3. In `App.tsx`, a `useEffect` hook listens for the `beforeinstallprompt` event, storing it in the Zustand store to be used by the `Footer.tsx` component.
- **Requirements**:
    - **FR-PWA-01**: The application MUST be installable via the `./manifest.json` file, with all paths specified relatively to support the sandboxed environment.
    - **FR-PWA-02**: The service worker MUST cache the core application shell for basic offline functionality.
    - **NFR-PWA-01**: Initial application load time MUST be under 3 seconds on a standard 4G connection.

### 3.2. Feature: Image Input & Editing
- **Execution Flow**:
    1. User initiates an upload, triggering the `isUploadOptionsOpen` modal in `App.tsx`.
    2. User selects "From File" (triggering a hidden `<input>`) or "Take Photo" (mounting `CameraCapture.tsx`).
    3. The captured image data URL is passed to the `ImageEditor.tsx` modal.
    4. User crops the image using `react-image-crop` (enforced 1:1 aspect ratio) and can apply rotation from -45° to +45°.
    5. On save, the cropped JPEG data URL is saved to the Zustand store via `setUploadedImage`.
- **Requirements**:
    - **FR-IMG-01**: The application MUST accept `image/png`, `image/jpeg`, and `image/webp` file types.
    - **FR-IMG-02**: The image editor MUST enforce a 1:1 aspect ratio for all user photos.
    - **FR-IMG-03**: Camera access permissions MUST be handled gracefully, displaying a user-friendly error message if denied.

### 3.3. Feature: AI Hairstyle Generation (4-Up Grid)
- **Execution Flow**:
    1. User provides input and clicks "Generate Pro", triggering `runGenerationSequence` in `App.tsx`.
    2. The app state is set to `generating-results`, and `generateFourUpImage` in `geminiService.ts` is called.
    3. The service resizes input images to a max of 1024px, constructs a detailed prompt specifying a 2x2 grid output, and calls the Gemini API.
    4. The API call is wrapped in `callGeminiWithRetry`, which attempts up to 3 retries with exponential backoff on internal server errors.
    5. The returned 2x2 grid image URL is processed by `cropFourUpSheet` in `lib/albumUtils.ts`, which slices it into four quadrant images.
    6. The four new image URLs are saved to the Zustand store, and `saveToHistory` is called.
- **Requirements**:
    - **FR-GEN-01**: The system MUST make a single API call to `gemini-2.5-flash-image-preview` to generate all four views for efficiency.
    - **FR-GEN-02**: The prompt engineering MUST include the "Identity Preservation" critical rule to maintain the user's likeness.
    - **FR-GEN-03**: The service layer MUST implement a retry mechanism for transient server-side API errors.
    - **NFR-GEN-01**: The entire image generation and cropping process should complete in under 30 seconds.

### 3.4. Feature: High-Resolution Upscaling & Download
- **Execution Flow**:
    1. User clicks a "Download" button, triggering a handler like `handleDownload` in `PolaroidCard.tsx`.
    2. The handler calls `getUpscaler` from `lib/upscaler.ts`, which manages a singleton `Upscaler.js` instance.
    3. `getUpscaler` initializes the TensorFlow.js backend (preferring WebGL, with a CPU fallback) and dynamically imports the 4x ESRGAN-Slim model. If the model fails to load, it falls back to the default built-in 2x model.
    4. The handler calls `upscaler.upscale()` with options `{ output: 'base64', patchSize: 64, padding: 2, progress: ... }`.
    5. The `progress` callback updates a `react-hot-toast` notification in real-time.
    6. On completion, the upscaled base64 URL is used to create and click a download link. If upscaling fails, the original image is downloaded instead.
- **Requirements**:
    - **FR-UP-01**: The application MUST upscale images using `patchSize` to prevent browser errors and enable progress tracking.
    - **FR-UP-02**: The system MUST provide real-time progress feedback to the user via a toast notification.
    - **FR-UP-03**: The system MUST gracefully fall back to downloading the original image if the upscaling process fails.
    - **NFR-UP-01**: Upscaling of a single 1024x1024 image should complete in under 15 seconds on a mid-range device with WebGL.

### 3.5. Feature: 360° Video Generation
- **Execution Flow**:
    1. User clicks "Create 360° Video", triggering `handleGenerateVideoClick` in `App.tsx`.
    2. The `generateHairstyleVideo` service in `geminiService.ts` is called with the generated "front" view image.
    3. The service initiates the generation with `veo-2.0-generate-001` and enters a `while` loop, polling the operation status every 10 seconds.
    4. A series of descriptive progress messages are passed back to the UI via an `onProgress` callback.
    5. When the operation is `done`, the final video file is fetched, converted to a blob URL, and saved in the Zustand store.
- **Requirements**:
    - **FR-VID-01**: Video generation MUST use the AI-generated "front" view image as its primary visual input.
    - **FR-VID-02**: The UI MUST display a sequence of progress messages to the user during the entire generation process.
    - **NFR-VID-01**: The UI must clearly communicate that video generation is a lengthy process (several minutes) to manage user expectations.

### 3.6. Feature: History Management
- **Execution Flow**:
    1. Upon successful generation, `saveToHistory` in `App.tsx` is called.
    2. All input and generated images are compressed to a maximum dimension of 512px using `compressImageForStorage`.
    3. A new `HistoryItem` object is created and prepended to the `generationHistory` array in the Zustand store, which persists to `localStorage`.
    4. The user can open the `HistoryPanel`, view past generations, and restore a session by clicking "Restore", which re-populates the entire application state.
- **Requirements**:
    - **FR-HIST-01**: The generation history MUST be automatically saved upon successful completion of a 4-up grid or video.
    - **FR-HIST-02**: Images stored in history MUST be compressed to manage `localStorage` quota.
    - **FR-HIST-03**: The application MUST cap the history at 50 items to prevent storage overflow.
    - **FR-HIST-04**: A one-time migration logic MUST run on app start to merge history from a plausible old `localStorage` key.

---
---
# 4. Proposal (Spec Kit Style) (from designspec.txt)
---

### Problem
Users struggle to visualize how a new hairstyle will look on them from all angles before committing to a change. Existing solutions are often unrealistic, limited to 2D, or lack personalization.

### Goals
- To provide a photorealistic, multi-angle AI preview of any described hairstyle on a user's own photo.
- To create a fast, reliable, and mobile-first PWA that is installable and works well on a variety of devices.
- To offer a high-quality user experience with features like high-resolution downloads, 360° video, and session history.

### Non-Goals
- To become a professional salon management tool.
- To support server-side rendering or user accounts (the app is entirely client-side).
- To offer real-time hair tracking via a live camera feed.

---
---
# 5. Risks & Mitigations (from designspec.txt)
---

- **Risk**: API changes or model deprecation by Google.
  - **Mitigation**: All API logic is isolated in `services/geminiService.ts`, creating a single point of adaptation.
- **Risk**: Hitting `localStorage` quota limits due to history.
  - **Mitigation**: History is capped at 50 items, all images are aggressively compressed, and a "Clear History" option is provided.
- **Risk**: Performance issues on low-end devices with WebGL/TensorFlow.js.
  - **Mitigation**: The upscaler explicitly manages the TF.js backend (WebGL with CPU fallback) and uses patch processing to reduce memory pressure.
- **Risk**: CDN instability for dependencies like the upscaler model.
  - **Mitigation**: The `lib/upscaler.ts` utility includes a try/catch block to fall back to a stable, built-in model if the dynamically imported model fails.

---
---
# 6. How to Run the Application (from AI prompt.txt)
---

The project uses `npm` for dependency management and Vite for the build process.

1.  **Install Dependencies**: `npm install`
    -   **Note**: You may need to use the `--legacy-peer-deps` flag if you encounter peer dependency conflicts with `@tensorflow/tfjs`.
2.  **Run the Development Server**: `npm run dev`
3.  **Create a Production Build**: `npm run build`
4.  **Preview the Production Build**: `npm run preview`

---
---
# 7. Known Issues & Limitations (from AI prompt.txt)
---

**End-to-End Testing is BLOCKED.**

-   **The Problem**: The development environment provided for this project has a fundamental constraint that prevents server processes (like `vite dev` or `vite preview`) from running correctly. It also appears to block the Playwright test runner from launching browser instances. All attempts to run servers or tests result in a timeout.
-   **Your Task**: Do not attempt to run the E2E tests (`npm run test:e2e`). The configuration files (`playwright.config.ts`, `e2e/` directory) have been left in the codebase for future use in a less restrictive environment. Focus on other development tasks.

---
---
# 8. Workspace Context & Troubleshooting Guide (from workspace_context.txt)
---

This document explains the unique characteristics of the development environment where Barber Booth Pro was built. Its purpose is to help developers distinguish between issues caused by the application's code and those caused by the specific constraints of the workspace. Understanding this context is crucial for effective debugging and successful deployment.

## 8.1. Environment Overview
This application is developed within a **browser-based, sandboxed IDE** (similar to Google's AI Studio). This environment is designed for rapid prototyping with live previews but comes with specific limitations that differ from a standard local development setup (like VS Code + a local server).

-   **Live Preview:** The app runs in a sandboxed `<iframe>` served from a unique, dynamically generated origin.
-   **No Local Server:** There is no `localhost`. The preview is served directly on a `usercontent.goog` domain.
-   **No Build Step:** The code runs as-is without a bundling or transpilation step (like Vite or Webpack).

## 8.2. Key Characteristics & Constraints

### 8.2.1. Origin & Cross-Origin Policy (CORS)
-   **The Problem:** The IDE's origin (e.g., `ai.studio`) is different from the live preview's origin (e.g., `*.scf.usercontent.goog`). This causes cross-origin security errors.
-   **Impact:** This is the primary cause of failures when registering the Progressive Web App (PWA) service worker.
-   **Solution:** All local file paths in `index.html` and `manifest.json` **must be relative** (e.g., `./service-worker.js` instead of `/service-worker.js`).

### 8.2.2. Dependency Management (`importmap`)
-   **The System:** The project does **not** use `package.json` or `npm`/`yarn`. All dependencies are managed via an **`importmap`** in `index.html`.
-   **How it Works:** The `importmap` tells the browser where to find modules when it sees an `import` statement. All packages are loaded at runtime as ES Modules directly from a CDN.
-   **Implications:**
    1.  **No `node_modules`:** All packages are remote.
    2.  **Versioning:** Package versions are controlled by changing the URL in the `importmap`.
    3.  **Custom Logic in Packages:** Some packages, like `Upscaler.js`, require their own JavaScript to run to set themselves up correctly.

### 8.2.3. API Keys
-   **Source:** The Gemini API key is provided securely by the environment as a `process.env.API_KEY` variable.
-   **Guideline:** Do not hardcode API keys.

## 8.3. Common Issues & Troubleshooting

### Issue 1: PWA Service Worker Registration Fails
-   **Console Error:** `ServiceWorker registration failed: ... The origin of the provided scriptURL (...) does not match the current origin (...)`
-   **Cause:** Using absolute paths in `manifest.json` or `<script>` tags.
-   **Fix:** **Ensure all local asset paths in `index.html` and `manifest.json` are relative (`./`).**

### Issue 2: Upscaler.js Fails (404, "Unknown Layer", or WebGL errors)
-   **Root Cause:** Difficulty of correctly loading a complex AI model within a browser-based `importmap` environment.
-   **The Robust Solution (`lib/upscaler.ts`):** A multi-layered solution was implemented:
    1.  **Explicit Backend Management:** Fallback from `webgl` to `cpu`.
    2.  **Dynamic Model Import with Fallback:** Fallback from a dynamically imported 4x model to the default built-in 2x model.
    3.  **Patch Processing for Robustness:** Using `patchSize` and `padding` to prevent WebGL errors and enable progress callbacks.

### Issue 3: Framer Motion TypeScript Errors
-   **Cause:** Version incompatibility or misconfiguration in the sandboxed IDE's TypeScript server.
-   **Fix (Workaround):** Using prop spreading (`{...{ initial: { opacity: 0 } }}`) or type casting to `any`.

## 8.4. Publishing to a Standard Environment
If you move this project to a standard hosting platform, you will need to:
1.  Create a `package.json`.
2.  Install dependencies via `npm`.
3.  Set up a build tool like Vite.
4.  Remove the `importmap`.
5.  Configure environment variables.

---
---
# 9. AI Studio Link (from README.md)
---
View your app in AI Studio: https://ai.studio/apps/drive/1cG745iiaS8VLfErKCcMSoXy5mN7_TbRl
