# Barber Booth Pro: Workspace Context & Troubleshooting Guide

**For a comprehensive breakdown of the application's features, user flows, and technical requirements, refer to the Technical Specification Sheet in `designspec.txt`.**

This document explains the unique characteristics of the development environment where Barber Booth Pro was built. Its purpose is to help developers distinguish between issues caused by the application's code and those caused by the specific constraints of the workspace. Understanding this context is crucial for effective debugging and successful deployment.

---

## 1. Environment Overview

This application is developed within a **browser-based, sandboxed IDE** (similar to Google's AI Studio). This environment is designed for rapid prototyping with live previews but comes with specific limitations that differ from a standard local development setup (like VS Code + a local server).

-   **Live Preview:** The app runs in a sandboxed `<iframe>` served from a unique, dynamically generated origin.
-   **No Local Server:** There is no `localhost`. The preview is served directly on a `usercontent.goog` domain.
-   **No Build Step:** The code runs as-is without a bundling or transpilation step (like Vite or Webpack).

---

## 2. Key Characteristics & Constraints

### 2.1. Origin & Cross-Origin Policy (CORS)

-   **The Problem:** The IDE's origin (e.g., `ai.studio`) is different from the live preview's origin (e.g., `*.scf.usercontent.goog`). This causes cross-origin security errors.
-   **Impact:** This is the primary cause of failures when registering the Progressive Web App (PWA) service worker. The browser's security policy prevents a script from one origin from registering a service worker on another.
-   **Solution:** All local file paths in `index.html` and `manifest.json` **must be relative** (e.g., `./service-worker.js` instead of `/service-worker.js`). This forces the browser to resolve paths based on the preview's dynamic origin, not the IDE's.

### 2.2. Dependency Management (`importmap`)

-   **The System:** The project does **not** use `package.json` or `npm`/`yarn`. All dependencies are managed via an **`importmap`** in `index.html`.
-   **How it Works:** The `importmap` tells the browser where to find modules when it sees an `import` statement. All packages are loaded at runtime as ES Modules directly from a CDN (like `esm.sh` or `jsdelivr`).
-   **Implications:**
    1.  **No `node_modules`:** All packages are remote.
    2.  **Versioning:** Package versions are controlled by changing the URL in the `importmap`. This can be brittle if a specific version is removed from the CDN.
    3.  **Custom Logic in Packages:** Some packages, like `Upscaler.js`, require their own JavaScript to run to set themselves up correctly (e.g., registering custom layers with TensorFlow.js). Simply linking to a model's `.json` file is often not enough.

### 2.3. API Keys

-   **Source:** The Gemini API key is provided securely by the environment as a `process.env.API_KEY` variable.
-   **Guideline:** Do not hardcode API keys or create UI for users to enter them. The application must assume this variable is present in its execution context.

---

## 3. Common Issues & Troubleshooting

This section addresses errors that have been encountered and resolved, which are often tied to the workspace's constraints.

### Issue 1: PWA Service Worker Registration Fails

-   **Console Error:** `ServiceWorker registration failed: ... The origin of the provided scriptURL (...) does not match the current origin (...)`
-   **Cause:** Using absolute paths (e.g., `start_url: "/"` in `manifest.json` or `<script src="/index.tsx">`) which the browser tries to resolve from the IDE's origin instead of the preview's origin.
-   **Fix:** **Ensure all local asset paths in `index.html` and `manifest.json` are relative (`./`).**

### Issue 2: Upscaler.js Fails (404, "Unknown Layer", or WebGL errors)

-   **Console Errors:**
    -   `Request to .../model.json failed with status code 404.`
    -   `Unknown layer: MultiplyBeta.`
    -   `Error: Failed to compile fragment shader.` (WebGL texture limit)
-   **Root Cause:** These errors all stem from the difficulty of correctly loading and running a complex AI model within a browser-based `importmap` environment, especially on large images or varied hardware. Hardcoding CDN paths is brittle, and static imports can fail to load the necessary setup scripts.
-   **The Robust Solution (`lib/upscaler.ts`):**
    A multi-layered solution was implemented in the `getUpscaler` utility to create a resilient and performant upscaling feature:
    1.  **Explicit Backend Management:** The utility first attempts to set the TensorFlow.js backend to `webgl` for GPU-accelerated performance. If this fails (e.g., due to lack of hardware support), it gracefully falls back to the `cpu` backend. This ensures the application works across a wide variety of devices, even those without powerful GPUs.
    2.  **Dynamic Model Import with Fallback:** The primary 4x upscaling model (`@upscalerjs/esrgan-slim`) is loaded using a dynamic `import()`. This is more reliable in a runtime `importmap` environment. If this import fails for any reason (e.g., CDN issue, 404), the code catches the error and gracefully falls back to the default, built-in `Upscaler.js` 2x model. This ensures the core upscaling feature remains functional, even if at a lower resolution.
    3.  **Patch Processing for Robustness:** Throughout the application, all calls to the `upscale` method use the `patchSize` and `padding` options. This is a critical fix that breaks large images into smaller tiles for processing. It directly solves two classic browser-based AI challenges:
        *   It prevents WebGL "texture size limit" errors that would otherwise crash the process when upscaling large images (like the 4-up sheet).
        *   It enables the `progress` callback to function correctly, providing essential user feedback during the (potentially long) upscaling process.

### Issue 3: Framer Motion TypeScript Errors
-   **Compiler Errors:** Widespread TypeScript errors related to `framer-motion` components, such as `Property 'initial' does not exist on type 'IntrinsicAttributes & MotionProps & RefAttributes<HTMLDivElement>'`. Similar errors occurred for `animate`, `exit`, `variants`, and gesture handlers like `onDragStart`.
-   **Cause:** This is characteristic of a version incompatibility or a misconfiguration within the sandboxed IDE's TypeScript language server and the type definitions provided by `framer-motion` via the CDN. The environment's type inference fails to correctly recognize valid props for motion components.
-   **Fix (Workaround):** Since the environment's configuration cannot be changed, targeted workarounds were applied to satisfy the compiler without compromising code functionality:
    1.  **Prop Spreading:** For standard motion props (`initial`, `animate`, etc.), wrapping them in a spread object (`<motion.div {...{ initial: { opacity: 0 } }} />`) bypasses the faulty JSX attribute type-checking for those specific properties while preserving type safety for all other props. This was the preferred method for simple props.
    2.  **Type Casting:** In more complex cases like `draggable-card.tsx`, where gesture handlers (`onDragStart`) conflicted with React's native event types and motion values were rejected in the `style` prop, type casting to `any` was used as a surgical fix (`onDragStart={... as any}`). This was a last resort to resolve intricate type conflicts that spreading could not address.

---

## 4. Publishing to a Standard Environment

If you move this project out of this sandboxed IDE to a standard hosting platform (Vercel, Netlify, Firebase, etc.), you will need to set up a more traditional development workflow.

1.  **Create a `package.json`:** Run `npm init -y`.
2.  **Install Dependencies:** Manually add all dependencies from the `importmap` to your `package.json` and run `npm install`.
3.  **Set Up a Build Tool:** Use a bundler like Vite (recommended for its speed and simplicity) or Create React App. This will handle bundling, minification, and managing environment variables.
4.  **Remove `importmap`:** Your build tool will now manage dependencies, so the `<script type="importmap">` block in `index.html` should be removed.
5.  **Environment Variables:** You will need to configure environment variables (specifically `VITE_API_KEY` for Vite) on your hosting platform.
